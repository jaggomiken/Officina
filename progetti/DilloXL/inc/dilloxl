/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 * DILLO EXTRA LARGE - DILLOXL
 * (C) Copyright by Michele Iacobellis
 * A project for students...
 * <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
#ifndef dilloxl_
#define dilloxl_

#include <cstdio>
#include <cstdint>
#include <cstring>
#include <string>
#include <thread>
#include <chrono>

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 * MACROS
 * <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
#define DILLOXL_IF_SYMBOL                                      "userprogram"
#define DILLOXL_IF_SOURCEFILENAME                          "userprogram.cpp"
#if defined(WIN32)
# define DILLOXL_IF_DLLNAME                                         "up.dll"
#else
# define DILLOXL_IF_DLLNAME                                          "up.so"
#endif

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 * MACROS
 * <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
#define DILLOXLHANG(c, m)\
  do { if (c) { std::fprintf(stderr, "%s", m); for(;;) {    \
    std::this_thread::sleep_for(std::chrono::seconds(1)); } \
  }} while(0)

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 * MACROS FOR USER PROGRAM
 * <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
#define dilloxl_do(what,arg) pctx->what arg
#define dilloxlprint(s) dilloxl_do(print_message,(s));
#define programma_inizio \
  extern "C" void userprogram(UserProgramContext* pctx) {
#define programma_fine }
#define numero_intero_positivo size_t
#define numero_con_la_virgola float
#define bandierina_vero_falso bool
#define falso false
#define vero true
#define crea_oggetto_da_astrazione(tipo) tipo
#define dando_nome(nome) nome;
#define messaggia_oggetto(nome,msg,arg) \
  dilloxlprint("METTO IN CODA IL MESSAGGIO " #msg " A " #nome "\n"); \
  nome.msg arg;
#define fine_questo }
#define per_sempre_fai_questo \
  dilloxlprint("STO PER FARE PER SEMPRE QUELLO CHE SCRIVI DOPO:\n"); \
  for(;;){
#define fai_questo_per_volte(a) \
  dilloxlprint("STO PER FARE " #a " VOLTE QUELLO CHE SCRIVI DOPO:\n"); \
  for (size_t passo_corrente = 0; passo_corrente < a; ++passo_corrente) {
#define fai_questo_finche_e_vero_che(a) \
  dilloxlprint("STO PER FARE FINCHE' E' VERO CHE " #a " QUELLO CHE SCRIVI DOPO:\n"); \
  while (a) {
#define fai_questo \
  dilloxlprint("STO PER FARE QUELLO CHE SCRIVI DOPO:\n"); \
  do {
#define e_rifallo_finche_e_vero_che(a) \
  dilloxlprint("E LO RIFACCIO SE E' VERO CHE " #a "...\n"); \
  } while (a);
#define se_e_vero_che(a)      if (a)
#define allora_fai_questo     {
#define altrimenti_fai_questo } else {
#define fai_dormire_il_processo_per_millisecondi(x) \
  dilloxlprint("IL PROCESSO DORME PER %u ms...\n",x); \
  std::this_thread::sleep_for(std::chrono::milliseconds(x));
#define chiedi_informazione_a(a) a.lastStatus().u.status
#define chiedi_a(a,m,c) a.m c;
#define cosa(a) .a;
#define e_anche &&
#define TELLO pctx

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 * STRUCTS
 * <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
struct UserProgramContext {
  static UserProgramContext* Get();
  void (*print_message)(const char*);
  void (*drone_move_left)(float);
  void (*drone_move_right)(float);
  void (*drone_move_up)(float);
  void (*drone_move_down)(float);
  void (*drone_rotate_cw)(float);
  void (*drone_rotate_cc)(float);
  void (*drone_forward)(float);
  void (*drone_backward)(float);
  void (*drone_takeoff)(float);
  void (*drone_land)(float);
  void* pOpaque;
};

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 * STRUCTS
 * <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
struct Drone {
  explicit Drone(UserProgramContext* p) : m_pctx{ p } {}
  void            vai_a_sinistra_cm(float v) { DILLOXLHANG(nullptr == m_pctx, "NULL"); m_pctx->drone_move_left(v); }
  void              vai_a_destra_cm(float v) { DILLOXLHANG(nullptr == m_pctx, "NULL"); m_pctx->drone_move_right(v); }
  void                    vai_su_cm(float v) { DILLOXLHANG(nullptr == m_pctx, "NULL"); m_pctx->drone_move_up(v); }
  void                   vai_giu_cm(float v) { DILLOXLHANG(nullptr == m_pctx, "NULL"); m_pctx->drone_move_down(v); }
  void     ruota_senso_orario_gradi(float v) { DILLOXLHANG(nullptr == m_pctx, "NULL"); m_pctx->drone_rotate_cw(v); }
  void ruota_senso_antiorario_gradi(float v) { DILLOXLHANG(nullptr == m_pctx, "NULL"); m_pctx->drone_rotate_cc(v); }
  void                vai_avanti_cm(float v) { DILLOXLHANG(nullptr == m_pctx, "NULL"); m_pctx->drone_forward(v); }
  void              vai_indietro_cm(float v) { DILLOXLHANG(nullptr == m_pctx, "NULL"); m_pctx->drone_backward(v); }
  void                      decolla(float v) { DILLOXLHANG(nullptr == m_pctx, "NULL"); m_pctx->drone_takeoff(v); }
  void                      atterra(float v) { DILLOXLHANG(nullptr == m_pctx, "NULL"); m_pctx->drone_land(v); }
private:
  UserProgramContext* m_pctx;
};

#endif // dilloxl_
